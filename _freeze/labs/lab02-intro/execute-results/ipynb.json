{
  "hash": "8e7ab362cedc8c68047a555bbe1a6bbd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Lab 2: Python and GitHub Bootcamp\"\nauthor: \"ENGS 199.20\"\ndate: last-modified\nformat:\n    html:        \n        warning: true\n        error: true\n        code-fold: true\n    ipynb:\n        warning: true\n        error: true\nexecute: \n    echo: true\n    enabled: true\njupyter: engs199\nengine: jupyter\nsidebar: main\n---\n\n\n\n\n\n\n\n\n\n\n\n\n## Overview\nToday we're going to practice our lab GitHub workflow and learn/refresh Python code for the types of analyses we'll see in future labs. There's a lot of content in this lab, so I will host an extra hour session on Tuesday so that I'm available for questions. Today's lab is not graded but I will provide feedback on your submission to provide guidance on expectations for future submissions. \n\nToday's objectives:\n\n1. Become more comfortable using [numpy](https://numpy.org/) for efficient array-based operations\n2. Become more comfortable using [pandas](https://pandas.pydata.org/) for structured data analysis\n3. Create a reproducible analysis with GitHub\n4. Get some practice using Python to address a *toy* decision analysis problem\n\nIt's pretty easy to find tutorials online for #1-#3 above. I thought it would be fun to have a more applied example. I will link to reference material and point out tips for where certain coding decisions come from to help you engage with that type of material. \n\nLet's pretend you just got hired as a flood risk analyst for an emergency management department. The city council has a budget to spend on flood mitigation strategies before the next storm season. Your job is to analyze two potential flood scenarios and provide actionable recommendations.\n\n:::{.callout-important}\nThis tutorial is for learning coding skills. We will violate a lot of decision analysis principles I will teach later in the term in service of meeting our primary objectives for today's lab. \n:::\n\n## Lab Workflow\n\n### GitHub Repository Setup\n\n1. Go to GitHub and create a new repository called \"toy-flood-analysis\"\n2. Clone the repo locally (I recommend using ssh as discussed last lab)\n3. Create the folder structure below\n\n```\ntoy-flood-analysis/\n   ├── data/\n   ├── notebooks/\n   ├── figures/\n   └── README.md\n   └── .gitignore\n```\n\nYour README.md should include the following structure:\n```\n# Toy Flood Analysis\n\n## Project Description\n[explain project]\n\n## How to Run\n[reproducibility instructions]\n```\n\nHere's an example of a GitHub repository with reproducibility instructions: <https://github.com/IMMM-SFA/burleyson-etal_2024_applied_energy>. You can check out the raw markdown [here](https://github.com/IMMM-SFA/burleyson-etal_2024_applied_energy/blob/main/Readme.md?plain=1).\n\nRemember to regularly add, commit, and push changes to your remote branch. \n\n### Setting up our computing environment\nCreate a file called `env-lock.yml` in your project directory. Add the following contents and save:\n```yaml\nname: lab2\nchannels:\n  - conda-forge\ndependencies:\n  - python\n  - pandas # great for tabular data\n  - numpy # great for efficient operations on large arrays\n  - matplotlib # standard plotting library for python\n  - nbconvert # for converting our notebook to pdf for submission\n  - ipykernel # for setting up the kernel for using this env in jupyter\n  - seaborn # good for exploratory data analysis and some final figures\n  - jupyter \n  - conda-lock\n```\nRun `mamba create -f env-lock.yml`. \nRun `mamba activate lab2`. \nSet up the kernel for the environment with `python -m ipykernel install --user --name lab2 --display-name lab2`.\n\n### Setting up our analysis\n\nCreate a new .ipynb file in the `notebooks/` subdirectory. In the first cell, let's import our tools for the analysis. \n\n::: {#670ee90c .cell execution_count=1}\n``` {.python .cell-code}\n# Core numerical computing\nimport numpy as np\n\n# Data manipulation and analysis\nimport pandas as pd\n\n# Visualization\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n```\n:::\n\n\n### Building our toy problem\n\nOur city is fake, so we have to build it. We will create a fake digital elevation grid, a fake built environment, and fake flood scenarios. \n\nBelow, we define a [function](https://docs.python.org/3/tutorial/controlflow.html#defining-functions) to create an elevation grid for the city. We use `numpy` because it's a great tool for setting up our 2d array. We will use a [meshgrid](https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html) to set up our grid.  \n\nPlease read the comments and test out any lines of code you want to understand better. I encourage you to reference the `numpy` documentation to read about any functions you're seeing for the first time. \n\n::: {#847baa62 .cell execution_count=2}\n``` {.python .cell-code}\ndef create_terrain(width=100, height=80):\n    \"\"\"\n    Create an elevation grid using numpy meshgrid\n\n    Key features:\n        - Rivers are the lowest elevations (like real topography)\n        - Land slopes toward rivers creating natural drainage\n        - Floodplains are flat areas adjacent to rivers\n        - Higher elevations are away from water\n\n    Keyword arguments:\n    width -- the number of columns in our elevation grid\n    height -- the number of rows in our elevation grid\n    \"\"\"\n    # Set seed for reproducible terrain\n    rng = np.random.default_rng(42)\n\n    # Create coordinate grids\n    x = np.linspace(0, width/10, width)\n    y = np.linspace(0, height/10, height)\n    X, Y = np.meshgrid(x, y)\n\n    # Define river path (straight east-west through middle)\n    river_center_y = height // 2\n    \n    # Create a slightly meandering river path\n    river_path = river_center_y + 6 * np.sin(np.linspace(0, 3*np.pi, width))\n    \n    # Calculate distance from each point to the river\n    # Elevation increases with distance from water\n    distance_to_river = np.zeros((height, width))\n    \n    for i in range(height):\n        for j in range(width):\n            river_y_at_x = river_path[j]\n            distance_to_river[i, j] = abs(i - river_y_at_x)\n    \n    # Create elevation based on distance to water\n    # Start with river at elevation 0, then build up from there\n    \n    # Base elevation: increases as you move away from river\n    elevation = distance_to_river * 1.2  # 1.2m rise per grid cell from river\n    \n    # Add gentle regional slope (slightly higher in the east)\n    elevation += X * 1.5\n    \n    # Add some rolling hills in areas far from the river\n    upland_mask = distance_to_river > 10\n    hill_effect = np.where(upland_mask, \n                          8 * np.sin(X * 0.6) * np.cos(Y * 0.5), \n                          0)\n    elevation += hill_effect\n    \n    # Create realistic floodplain (very flat near river)\n    floodplain_mask = distance_to_river < 3\n    elevation[floodplain_mask] = distance_to_river[floodplain_mask] * 0.3 + X[floodplain_mask] * 0.5\n    \n    # Ensure river channel is the absolute lowest point\n    river_mask = distance_to_river < 1\n    elevation[river_mask] = X[river_mask] * 0.2  # Gentle downstream slope\n    \n    # Add small-scale variation\n    elevation += np.random.normal(0, 0.5, elevation.shape)\n    \n    # Ensure no negative elevations\n    elevation = np.maximum(elevation, 0)\n    \n    return elevation, distance_to_river\n\n# Generate terrain\nterrain, river_distance = create_terrain()\n\n# Create a much better visualization\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Elevation map with proper terrain colormap\nim1 = ax.imshow(terrain, cmap='terrain', origin='lower')\nax.axis('off')\nplt.colorbar(im1, ax=ax, label='Elevation (m)')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](lab02-intro_files/figure-ipynb/cell-3-output-1.png){}\n:::\n:::\n\n\nNow we'll use both `numpy` and `pandas` to set up our building inventory. There are a lot of things that go into where people build & occupy buildings with respect to flood hazard, but we're going to ignore that in setting up this problem. (You have no idea how uncommon it is for your instructor to let explanations on those things slide!)\n\n::: {#df8e5630 .cell execution_count=3}\n``` {.python .cell-code}\ndef generate_building_inventory(terrain, n_buildings=500, min_elevation=10):\n    \"\"\"\n    Creates building inventory, excluding buildings in flood-prone areas.\n    \n    Generate buildings randomly, then filter out those \n    below minimum elevation.\n\n    Keyword arguments:\n    terrain -- digital elevation grid\n    n_buildings -- the max number of buildings in the city\n    min_elevation -- the lowest elevation a building can have\n    \"\"\"\n    # Set seed for reproducible inventory\n    rng = np.random.default_rng(42)\n\n    # Keep track of grid dimensions\n    height, width = terrain.shape\n    \n    # Vectorized location sampling\n    x_coords = rng.integers(0, width, n_buildings)\n    y_coords = rng.integers(0, height, n_buildings)\n    \n    # Get elevations using numpy indexing\n    elevations = terrain[y_coords, x_coords]\n    \n    # Keep only buildings above minimum elevation\n    # This automatically excludes buildings in the river, and some near\n    valid_mask = elevations > min_elevation\n    \n    # Apply filter to all arrays\n    x_coords = x_coords[valid_mask]\n    y_coords = y_coords[valid_mask]\n    elevations = elevations[valid_mask]\n    \n    # Check how many buildingds we're left with\n    n_actual = len(x_coords)\n    \n    # Generate building characteristics (vectorized)\n    building_types = rng.choice(\n        ['residential', 'commercial', 'industrial'],\n        size=n_actual,\n        p=[0.75, 0.2, 0.05]\n    )\n    \n    # Structure values by type (vectorized with masks)\n    values = np.zeros(n_actual)\n    residential_mask = (building_types == 'residential')\n    commercial_mask = (building_types == 'commercial')\n    industrial_mask = (building_types == 'industrial')\n    \n    values[residential_mask] = rng.lognormal(12, 0.5, residential_mask.sum())\n    values[commercial_mask] = rng.lognormal(13, 0.7, commercial_mask.sum())\n    values[industrial_mask] = rng.lognormal(14, 0.8, industrial_mask.sum())\n\n    # Create DataFrame\n    buildings = pd.DataFrame({\n        'bld_id': [f'{i:04d}' for i in range(n_actual)],\n        'x': x_coords,\n        'y': y_coords,\n        'elevation': elevations,\n        'type': building_types,\n        'value': values\n    })\n    \n    return buildings\n\n# Generate building inventory\nbuildings = generate_building_inventory(terrain, n_buildings=500, min_elevation=10)\n\n\n# Visualize building locations on terrain\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Show terrain\nimg = ax.imshow(terrain, cmap='terrain', origin='lower', alpha=0.8)\ncbar = plt.colorbar(img)\ncbar.set_label('Elevation (m)', size=14, rotation=90)\ncbar.ax.tick_params(labelsize=12)\n\n# Add building locations colored by type\ncolors = {'residential': 'red', 'commercial': 'blue', 'industrial': 'purple'}\nfor building_type, color in colors.items():\n    type_buildings = buildings[buildings['type'] == building_type]\n    ax.scatter(type_buildings['x'], type_buildings['y'], \n               c=color, s=20, alpha=0.7, label=building_type)\n\nax.legend(bbox_to_anchor=(.5, -.1),\n          loc='center',\n          ncols=3,\n          fontsize=14,\n          title_fontsize=14,\n          title='Occupancy')\nax.axis('off')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](lab02-intro_files/figure-ipynb/cell-4-output-1.png){}\n:::\n:::\n\n\nNow we'll generate two flood scenarios. We'll organize our parameterizations for each scenario using dictionaries. Then we'll simulate the floods in a highly stylized fashion to get depth grids. \n\n::: {#51544a82 .cell execution_count=4}\n``` {.python .cell-code}\nscenarios = {\n        'moderate': {\n            'name': 'Moderate Flood',\n            'rainfall_mm': 100,\n            'river_discharge_multiplier': 3.0,\n            'storm_duration_hours': 12\n        },\n        'extreme': {\n            'name': 'Extreme Flood', \n            'rainfall_mm': 200,\n            'river_discharge_multiplier': 6.0,\n            'storm_duration_hours': 24\n        }\n    }\n\ndef simulate_flood(terrain, river_distance, scenario_params):\n    \"\"\"\n    Simple linear flood model based on terrain characteristics.\n    \n    Flood depth depends on:\n    - Base scenario intensity\n    - Distance to river (closer = more flooding)\n    - Elevation (lower = more flooding)\n    - Random noise (varies by distance to river)\n\n    Keyword arguments:\n    terrain -- digital elevation grid\n    river_distance -- grid of distances from river\n    scenario_params -- dict of flood scenario details\n    \"\"\"\n    # Random seed for reproducibility\n    rng = np.random.default_rng(42)\n\n    # Base flood intensity from scenario\n    base_intensity = scenario_params['rainfall_mm'] / 1000  # Convert to meters\n    river_intensity = base_intensity * scenario_params['river_discharge_multiplier']\n    \n    # Linear model for flood depth\n    # Flood depth = base + river_effect + elevation_effect + noise\n    \n    # River effect: flooding decreases with distance from river\n    river_effect = np.maximum(0, river_intensity * (10 - river_distance) / 10)\n    \n    # Elevation effect: flooding decreases with elevation above minimum\n    min_elevation = np.min(terrain)\n    elevation_effect = np.maximum(0, base_intensity * (35 - (terrain - min_elevation)) / 35)\n    \n    # Spatially varying noise\n    # More variability near river (complex hydrology)\n    # Less variability on uplands (simple runoff)\n    noise_scale = 0.1 * base_intensity * (1 + 0.5 / (1 + river_distance))\n    noise = rng.normal(0, noise_scale, terrain.shape)\n    \n    # Combine effects\n    flood_depth = river_effect + elevation_effect + noise\n    \n    # Ensure realistic constraints\n    # No negative depths\n    flood_depth = np.maximum(flood_depth, 0)\n    \n    # Cap maximum depth (physical limit)\n    flood_depth = np.minimum(flood_depth, 5.0)\n    \n    # Areas above certain elevation rarely flood\n    high_elevation_mask = terrain > (min_elevation + 40)\n    flood_depth[high_elevation_mask] *= 0.1  # Reduce flooding on high ground\n    \n    # Very small depths set to zero (not meaningful flooding)\n    flood_depth[flood_depth < 0.02] = 0\n    \n    return flood_depth\n\n# Run the simplified simulations\nflood_results = {}\n\nfor scenario_id, params in scenarios.items():\n    flood_depth = simulate_flood(terrain, river_distance, params)\n    flood_results[scenario_id] = {\n        'depth': flood_depth,\n        'params': params,\n        'flooded_cells': np.sum(flood_depth > 0.01),  # 1cm threshold\n        'max_depth': np.max(flood_depth),\n        'mean_depth': np.mean(flood_depth[flood_depth > 0.01]) if np.any(flood_depth > 0.01) else 0\n    }\n\n# Enhanced visualization with proper handling of zero flood depths\nfig, axes = plt.subplots(2, 2, figsize=(16, 12), sharey='col')\n\nfor i, (scenario_id, results) in enumerate(flood_results.items()):\n    row = i\n    \n    # Only show flood depths, gray for no flooding\n    flood_depth_viz = results['depth'].copy()\n    \n    # Create a masked array where zeros are masked\n    flood_depth_masked = np.ma.masked_where(flood_depth_viz <= 0.01, flood_depth_viz)\n    \n    # Show only flood depths (zeros will be transparent, showing gray background)\n    im = axes[row, 0].imshow(flood_depth_masked, cmap='Blues', vmin=0, vmax=1)\n    \n    axes[row, 0].set_title(f\"{results['params']['name']}\")\n    \n    # Add colorbar with proper label\n    cbar = plt.colorbar(im, ax=axes[row, 0], extend='max', label='Flood Depth (m)')\n    \n    # Show flooded and non-flooded areas\n    # Get all terrain elevations\n    all_elevations = terrain.flatten()\n    all_flood_depths = results['depth'].flatten()\n    \n    # Separate flooded and non-flooded areas\n    flooded_mask = all_flood_depths > 0.01\n    non_flooded_mask = all_flood_depths <= 0.01\n    \n    # Plot non-flooded areas (gray triangles)\n    if np.any(non_flooded_mask):\n        axes[row, 1].scatter(all_elevations[non_flooded_mask], \n                           all_flood_depths[non_flooded_mask],\n                           c='lightgray', marker='^', s=8, alpha=1, \n                           label='No flooding')\n    \n    # Plot flooded areas (blue circles)\n    if np.any(flooded_mask):\n        scatter = axes[row, 1].scatter(all_elevations[flooded_mask], \n                                     all_flood_depths[flooded_mask],\n                                     c=all_flood_depths[flooded_mask], \n                                     cmap='Blues', s=12, alpha=1,\n                                     vmin=0, vmax=1,\n                                     label='Flooded')\n        \n        # Add colorbar for scatter plot\n        plt.colorbar(scatter, ax=axes[row, 1], extend='max', label='Flood Depth (m)')\n    \n    axes[row, 1].set_xlabel('Terrain Elevation (m)')\n    axes[row, 1].set_ylabel('Flood Depth (m)')\n    axes[row, 1].set_title(f\"{results['params']['name']}\\nElevation vs Flood Depth\")\n    axes[row, 1].grid(True, alpha=0.3)\n    axes[row, 1].legend()\n    \n    # Add some summary statistics as text\n    flooded_cells = np.sum(flooded_mask)\n    total_cells = len(all_elevations)\n    flood_percentage = (flooded_cells / total_cells) * 100\n       \n    # Add text box with statistics\n    stats_text = f'Flooded: {flooded_cells:,} cells ({flood_percentage:.1f}%)\\n'\n    stats_text += f'Max depth: {results[\"max_depth\"]:.2f}m'\n    axes[row, 1].text(0.42, 0.98, stats_text, transform=axes[row, 1].transAxes, \n                     verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](lab02-intro_files/figure-ipynb/cell-5-output-1.png){}\n:::\n:::\n\n\n### Analyzing risk\n\nNow it's time to calculate flood damages. We will identify which buildings face flooding in each scenario, then will apply (made up) depth-damage functions to translate exposure into damages. These functions return damage as a fraction of building value, so we will scale these outputs by each building's value. \n\n::: {#54f6ee40 .cell execution_count=5}\n``` {.python .cell-code}\n# Get building depths for each scenario\nfor scenario_id, results in flood_results.items():\n    depths = results['depth'][buildings['y'], buildings['x']]\n    buildings['depth_{}'.format(scenario_id)] = pd.Series(depths)\n\n# Function for estimating damages\ndef calc_flood_damages(buildings, depth_col):\n    \"\"\"\n    Estimate flood damages for the merged flood scenarios\n\n    Keyword arguments:\n    buildings -- our building inventory\n    depth_cols -- name of the flood scenario to calculate damages\n\n    Note: we must have preprocessed depth columns in the buildings dataframe\n    to avoid throwing an Error (it's much better to explicitly handle this if you can!)\n    \"\"\"\n\n    # Set seed for reproducibility\n    rng = np.random.default_rng(42)\n\n    # Helpful to have a function for the depth-damage curves\n    def damage_curve_deterministic(depth, building_type):\n        \"\"\"\n        Base damage curves without noise - cleaner for teaching the core concept.\n        \"\"\"\n        if depth <= 0.01: \n            return 0\n        elif depth <= 0.25:  \n            if building_type == 'residential':\n                return 0.1 + 0.3 * (depth - 0.1) / 0.4\n            else:\n                return 0.05 + 0.2 * (depth - 0.1) / 0.4\n        elif depth <= .75:  \n            if building_type == 'residential':\n                return 0.4 + 0.3 * (depth - 0.5) / 0.5\n            else:\n                return 0.25 + 0.4 * (depth - 0.5) / 0.5\n        else:  \n            if building_type == 'residential':\n                return min(0.7 + 0.2 * (depth - 1.0), 0.95)\n            else:\n                return min(0.65 + 0.25 * (depth - 1.0), 0.90)\n    \n    # Calculate deterministic damage ratios using vectorized pandas apply\n    damage_ratios_base = buildings.apply(\n        lambda row: damage_curve_deterministic(row[depth_col], row['type']), \n        axis=1\n    )\n\n    # Add noise\n    # Uncertainty increases with predicted damage level\n    # Low damage = low uncertainty, High damage = high uncertainty\n    # Create noise scale that increases with predicted damage\n    # No noise for zero damage, maximum noise for high damage\n    noise_scale = 0.15 * damage_ratios_base  # 15% relative noise\n        \n    # Generate heteroskedastic noise\n    damage_noise = rng.normal(0, noise_scale)\n    \n    # Apply noise to damage ratios\n    damage_ratios_noisy = damage_ratios_base + damage_noise\n    \n    # Ensure realistic bounds (damage ratios must be between 0 and 1)\n    damage_ratios_final = np.clip(damage_ratios_noisy, 0, 1)\n        \n    # Return damage amounts\n    return buildings['value'] * damage_ratios_final\n\n# Calculate damages\n# Identify depth columns and loop through them\n# Store the scenario name to create the damage column\n\n# This is called list comprehension - very handy!\ndepth_cols = [x for x in buildings.columns if 'depth' in x]\n# Our names of interest come after a '_' so we can split our strings\nfor d_col in depth_cols:\n    # This returns a list of strings after splitting on '_'\n    # and we want the last indexed string in that list\n    scenario = d_col.split('_')[-1]\n    dam_col = 'damage_{}'.format(scenario)\n    damage = calc_flood_damages(buildings, d_col)\n    buildings[dam_col] = damage\n\n\n## Diagnostic plot\nfig, (ax1, ax2) = plt.subplots(2, 1,\n                               sharex=True,\n                               figsize=(14, 10))\n    \n# Define colors and scenario info\nscenarios_plot = {\n    'moderate_flood': {\n        'color': 'blue',\n        'label': 'Moderate Flood',\n        'depth_col': 'depth_moderate',\n        'damage_col': 'damage_moderate'\n    },\n    'extreme_flood': {\n        'color': 'red', \n        'label': 'Extreme Flood',\n        'depth_col': 'depth_extreme',\n        'damage_col': 'damage_extreme'\n    }\n}\n\nmin_dam_depth = .01\n\n# Cumulative damage curves\nfor scenario_id, info in scenarios_plot.items():\n    # Filter to buildings with flooding in this scenario\n    flooded_buildings = buildings[\n        buildings[info['depth_col']] > min_dam_depth\n    ].copy()\n    \n    if len(flooded_buildings) > 0:\n        # Sort by flood depth\n        flooded_buildings = flooded_buildings.sort_values(info['depth_col'])\n        \n        # Calculate cumulative damage\n        cumulative_damage = flooded_buildings[info['damage_col']].cumsum()\n        flood_depths = flooded_buildings[info['depth_col']]\n        \n        # Create step plot\n        ax1.step(flood_depths, cumulative_damage / 1e6, \n                where='post', linewidth=2.5, \n                color=info['color'], label=info['label'])\n        \nax1.set_ylabel('Cumulative Damage ($ millions)', size=14)\nax1.set_title('Cumulative Damage by Flood Depth\\n(Step plot shows damage accumulation)', fontsize=14)\nax1.grid(True, alpha=0.3)\nax1.legend(fontsize=12)\n\n# Overlapping histograms of flood depths\nfor scenario_id, info in scenarios_plot.items():\n    flood_depths = buildings[info['depth_col']]\n    flooded_depths = flood_depths[flood_depths > min_dam_depth]\n    \n    if len(flooded_depths) > 0:\n        ax2.hist(flooded_depths, bins=30, alpha=0.6, \n                color=info['color'], label=info['label'],\n                edgecolor='black', linewidth=0.5, density=True)\n\nax2.set_xlabel('Flood Depth (m)', size=14)\nax2.set_ylabel('Density', size=14)\nax2.grid(True, alpha=0.3)\n\n# Add summary statistics as text annotations\nsummary_text = \"SCENARIO SUMMARY:\\n\\n\"\n\nfor scenario_id, info in scenarios_plot.items():\n    flood_depths = buildings[info['depth_col']]\n    damages = buildings[info['damage_col']]\n    \n    # Calculate statistics\n    n_flooded = np.sum(flood_depths > min_dam_depth)\n    total_damage = damages.sum()\n    mean_damage = damages[damages > 0].mean() if np.any(damages > 0) else 0\n    max_depth = flood_depths.max()\n    mean_depth = flood_depths[flood_depths > min_dam_depth].mean() if np.any(flood_depths > min_dam_depth) else 0\n    \n    summary_text += f\"{info['label']}:\\n\"\n    summary_text += f\"  • Buildings flooded: {n_flooded:,}\\n\"\n    summary_text += f\"  • Total damage: ${total_damage/1e6:.1f}M\\n\"\n    summary_text += f\"  • Mean damage: ${mean_damage/1e3:.0f}K\\n\"\n    summary_text += f\"  • Max depth: {max_depth:.2f}m\\n\"\n    summary_text += f\"  • Mean depth: {mean_depth:.2f}m\\n\\n\"\n\n# Add text box with statistics\nsummary_text += f\"Total buildings: {len(buildings)}\"\nax2.text(0.8, 0.2, summary_text, transform=ax2.transAxes,\n            fontsize=12,\n            bbox=dict(boxstyle='round,pad=0.5', facecolor='white', alpha=0.9))\n\nax1.tick_params(labelsize=12)\nax2.tick_params(labelsize=12)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](lab02-intro_files/figure-ipynb/cell-6-output-1.png){}\n:::\n:::\n\n\nNow we compare different flood mitigation options. We will make very rudimentary assumptions about costs and benefits for different actions. While the text table does not render colors on the website, checkout what happens in your Jupyter notebook!\n\n::: {#a54d6b74 .cell execution_count=6}\n``` {.python .cell-code}\ndef analyze_mitigation_strategies_multi_scenario(buildings):\n    \"\"\"\n    Evaluates mitigation strategies across both flood scenarios.\n    \"\"\"\n    \n    # Calculate baseline damages for both scenarios\n    baseline_moderate = buildings['damage_moderate'].sum()\n    baseline_extreme = buildings['damage_extreme'].sum()\n    \n    print(f\"Baseline damages:\")\n    print(f\"  Moderate flood: ${baseline_moderate:,.0f}\")\n    print(f\"  Extreme flood: ${baseline_extreme:,.0f}\")\n    \n    # Define mitigation strategies\n    strategies = {\n        'do_nothing': {\n            'cost': 0,\n            'damage_reduction_moderate': 0,\n            'damage_reduction_extreme': 0,\n            'description': 'Accept current flood risk'\n        },\n        'early_warning': {\n            'cost': 500_000,\n            'damage_reduction_moderate': 0.15,  # 15% reduction through evacuation\n            'damage_reduction_extreme': 0.12,   # Less effective in extreme events\n            'description': 'Flood warning system + evacuation plans'\n        },\n        'levees': {\n            'cost': 25_000_000,\n            'damage_reduction_moderate': 0.70,  # Very effective for moderate floods\n            'damage_reduction_extreme': 0.45,   # Less effective for extreme floods\n            'description': 'Construct flood levees along river'\n        },\n        'buyouts': {\n            'cost': 15_000_000,  # Simplified cost\n            'damage_reduction_moderate': 0.35,  # Remove highest-risk buildings\n            'damage_reduction_extreme': 0.40,   # More effective in extreme events\n            'description': 'Buy out highest-risk properties'\n        },\n        'green_infrastructure': {\n            'cost': 12_000_000,\n            'damage_reduction_moderate': 0.30,  # Natural storage\n            'damage_reduction_extreme': 0.35,   # Better performance in extreme events\n            'description': 'Wetland restoration + permeable surfaces'\n        },\n        'combined_approach': {\n            'cost': 18_000_000,\n            'damage_reduction_moderate': 0.50,  # Combines multiple strategies\n            'damage_reduction_extreme': 0.6,   # Better performance in extremes\n            'description': 'Early warning + green infrastructure + targeted buyouts'\n        }\n    }\n    \n    # Calculate metrics for each strategy\n    strategy_analysis = []\n    \n    for name, strategy in strategies.items():\n        # Calculate avoided damages for both scenarios\n        avoided_moderate = baseline_moderate * strategy['damage_reduction_moderate']\n        avoided_extreme = baseline_extreme * strategy['damage_reduction_extreme']\n        \n        # Calculate net benefits\n        net_benefit_moderate = avoided_moderate - strategy['cost']\n        net_benefit_extreme = avoided_extreme - strategy['cost']\n\n        strategy_analysis.append({\n            'strategy': name,\n            'description': strategy['description'],\n            'cost': strategy['cost'],\n            'avoided_damage_moderate': avoided_moderate,\n            'avoided_damage_extreme': avoided_extreme,\n            'net_benefit_moderate': net_benefit_moderate,\n            'net_benefit_extreme': net_benefit_extreme\n        })\n    \n    return pd.DataFrame(strategy_analysis)\n\n# Run the multi-scenario analysis\nstrategy_results = analyze_mitigation_strategies_multi_scenario(buildings)\n\n# Create a nicely formatted table with colors\ndef print_strategy_table(strategy_df):\n    \"\"\"\n    Pretty print the strategy analysis table with colored output.\n    Red for costs, black for benefits.\n    \"\"\"\n    \n    # ANSI color codes\n    RED = '\\033[91m'\n    GREEN = '\\033[92m'\n    BLUE = '\\033[94m'\n    BOLD = '\\033[1m'\n    END = '\\033[0m'\n    \n    print(f\"\\n{BOLD} MITIGATION STRATEGY ANALYSIS - MULTI-SCENARIO{END}\")\n    print(\"=\"*100)\n    \n    # Table header\n    print(f\"{BOLD}{'Strategy':<20} {'Cost':<12} {'Avoided Damage':<25} {'Net Benefit':<25}{END}\")\n    print(f\"{BOLD}{'':20} {'($M)':<12} {'Mod/Ext ($M)':<25} {'Mod/Ext ($M)':<25}{END}\")\n    print(\"-\" * 100)\n    \n    for idx, row in strategy_df.iterrows():\n        strategy_name = row['strategy'].replace('_', ' ').title()\n        \n        # Format costs (red)\n        cost_str = f\"{RED}${row['cost']/1e6:.1f}{END}\"\n        \n        # Format avoided damages (green if positive)\n        avoided_mod = row['avoided_damage_moderate'] / 1e6\n        avoided_ext = row['avoided_damage_extreme'] / 1e6\n        avoided_str = f\"{GREEN}${avoided_mod:.1f}/${avoided_ext:.1f}{END}\"\n        \n        # Format net benefits (green if positive, red if negative)\n        net_mod = row['net_benefit_moderate'] / 1e6\n        net_ext = row['net_benefit_extreme'] / 1e6\n        \n        net_mod_color = GREEN if net_mod > 0 else RED\n        net_ext_color = GREEN if net_ext > 0 else RED\n        net_str = f\"{net_mod_color}${net_mod:.1f}{END}/{net_ext_color}${net_ext:.1f}{END}\"\n        \n        print(f\"{strategy_name:<20} {cost_str:<20} {avoided_str:<35} {net_str:<35}\")\n    \n    print(\"\\n\" + \"=\"*100)\n    print(f\"{BOLD}Legend:{END}\")\n    print(f\"  • {GREEN}Green{END} = Positive value (benefit)\")\n    print(f\"  • {RED}Red{END} = Negative value (cost)\")\n    print(f\"  • Mod/Ext = Moderate/Extreme flood scenarios\")\n\n# Print the formatted table\nprint_strategy_table(strategy_results)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBaseline damages:\n  Moderate flood: $3,295,652\n  Extreme flood: $11,712,878\n\n MITIGATION STRATEGY ANALYSIS - MULTI-SCENARIO\n====================================================================================================\nStrategy             Cost         Avoided Damage            Net Benefit              \n                     ($M)         Mod/Ext ($M)              Mod/Ext ($M)             \n----------------------------------------------------------------------------------------------------\nDo Nothing           $0.0        $0.0/$0.0                  $0.0/$0.0        \nEarly Warning        $0.5        $0.5/$1.4                  $-0.0/$0.9       \nLevees               $25.0       $2.3/$5.3                  $-22.7/$-19.7    \nBuyouts              $15.0       $1.2/$4.7                  $-13.8/$-10.3    \nGreen Infrastructure $12.0       $1.0/$4.1                  $-11.0/$-7.9     \nCombined Approach    $18.0       $1.6/$7.0                  $-16.4/$-11.0    \n\n====================================================================================================\nLegend:\n  • Green = Positive value (benefit)\n  • Red = Negative value (cost)\n  • Mod/Ext = Moderate/Extreme flood scenarios\n```\n:::\n:::\n\n\n### Wrapping up the analysis\n1. Save your figures in the `figures/` subdirectory (check the resolution)\n2. Finalize a comprehensive `.README`\n3. Push final changes to GitHub (hopefully you made commits throughout)\n4. Convert your notebook to pdf and submit on Canvas\n\n**Note:** If you would like to experiment with code, I am happy to review and provide feedback! For example, you might want to create a new notebook where you initialize a different terrain and/or flood model, building representation, etc., You might want to try adding figures to your main notebook, or flood scenarios. If you want practice and have some extra time, go for it! \n\n---\njupyter:\n  kernelspec:\n    display_name: engs199\n    language: python\n    name: engs199\n    path: /Users/adampollack/Library/Jupyter/kernels/engs199\n---\n",
    "supporting": [
      "lab02-intro_files/figure-ipynb"
    ],
    "filters": []
  }
}